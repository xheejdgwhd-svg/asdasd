<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AI Hand-Drawing — Gesture Paint</title>
  <style>
    :root{--bg:#0b1220;--card:#0f1724;--muted:#9aa4b2;--accent:#06b6d4}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;color:#e6eef8;background:linear-gradient(180deg,#071427,#021019)}
    .app{max-width:1100px;margin:28px auto;padding:18px;border-radius:12px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);box-shadow:0 10px 40px rgba(2,6,23,0.6)}
    .top{display:flex;align-items:center;gap:16px}
    h1{margin:0;font-size:18px}
    p.lead{margin:0;color:var(--muted);font-size:13px}
    .stage{position:relative;margin-top:14px;border-radius:12px;overflow:hidden;background:#000}
    video#video{width:100%;height:auto;display:block;transform:scaleX(-1);object-fit:cover}
    canvas#overlay{position:absolute;left:0;top:0;pointer-events:none;transform:scaleX(-1)}
    canvas#draw{position:absolute;left:0;top:0;pointer-events:none;transform:scaleX(-1)}

    .controls{display:flex;gap:8px;align-items:center;margin-top:12px}
    .card{background:var(--card);padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.03)}
    .btn{background:linear-gradient(90deg,var(--accent),#7c3aed);border:none;color:white;padding:8px 10px;border-radius:8px;cursor:pointer}
    label.small{font-size:13px;color:var(--muted);display:flex;align-items:center;gap:8px}
    input[type=range]{width:120px}
    .status{margin-left:auto;color:var(--muted);font-size:13px}

    .hint{margin-top:10px;color:var(--muted);font-size:13px}

    @media (max-width:760px){.controls{flex-wrap:wrap}}
  </style>
</head>
<body>
  <main class="app">
    <div class="top">
      <div style="width:56px;height:56px;border-radius:10px;background:linear-gradient(135deg,#06b6d4,#7c3aed);display:flex;align-items:center;justify-content:center;font-weight:700;color:#021019">HD</div>
      <div>
        <h1>AI Hand-Drawing — Gesture Paint</h1>
        <p class="lead">Use your webcam: touch index tip to thumb to draw. Release to pause. Minimal UI — smooth realtime interaction.</p>
      </div>
    </div>

    <div class="stage" id="stage">
      <video id="video" autoplay playsinline></video>
      <canvas id="overlay"></canvas>
      <canvas id="draw"></canvas>
    </div>

    <div class="controls">
      <div class="card">
        <button id="startBtn" class="btn">Start Camera</button>
        <button id="stopBtn" class="btn" style="background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);margin-left:8px">Stop</button>
      </div>

      <div class="card" style="display:flex;gap:8px;align-items:center">
        <label class="small">Color <input id="color" type="color" value="#06b6d4" style="margin-left:6px"></label>
        <label class="small">Brush <input id="size" type="range" min="1" max="40" value="6"></label>
        <button id="clear" class="btn" style="background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)">Clear</button>
        <button id="save" class="btn">Save</button>
      </div>

      <div class="status card" id="status">Status: idle</div>
    </div>

    <div class="hint">Tip: mirror is ON for natural interaction. The app detects fingertips using MediaPipe Hands and treats index-thumb contact as the drawing trigger.</div>
  </main>

  <script>
    // Single-file Hand Drawing app using MediaPipe Hands (browser)
    // Imported via CDN below when starting camera to avoid blocking.

    const video = document.getElementById('video');
    const overlay = document.getElementById('overlay');
    const drawCanvas = document.getElementById('draw');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const clearBtn = document.getElementById('clear');
    const saveBtn = document.getElementById('save');
    const colorInput = document.getElementById('color');
    const sizeInput = document.getElementById('size');
    const statusEl = document.getElementById('status');

    let camera = null;
    let hands = null;
    let drawing = false;
    let lastPoint = null;
    let smoothing = {x:0,y:0};

    function setStatus(t){ statusEl.textContent = 'Status: '+t }

    function fitCanvases(){
      const rect = video.getBoundingClientRect();
      [overlay, drawCanvas].forEach(c=>{
        c.width = rect.width;
        c.height = rect.height;
        c.style.left = '0px';
        c.style.top = '0px';
      });
    }

    function distance(a,b,w,h){
      // landmarks are normalized (0..1) relative to video width/height before mirroring
      const dx = (a.x - b.x) * w;
      const dy = (a.y - b.y) * h;
      return Math.hypot(dx,dy);
    }

    function midpoint(a,b,w,h){
      return {x: ((a.x + b.x)/2) * w, y: ((a.y + b.y)/2) * h};
    }

    function drawLineTo(p){
      const ctx = drawCanvas.getContext('2d');
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.strokeStyle = colorInput.value;
      ctx.lineWidth = Number(sizeInput.value);
      if(!lastPoint){ ctx.beginPath(); ctx.moveTo(p.x,p.y); lastPoint = p; return }
      // smoothing - exponential moving average
      smoothing.x = smoothing.x * 0.7 + p.x * 0.3;
      smoothing.y = smoothing.y * 0.7 + p.y * 0.3;
      ctx.beginPath();
      ctx.moveTo(lastPoint.x, lastPoint.y);
      ctx.lineTo(smoothing.x, smoothing.y);
      ctx.stroke();
      lastPoint = {x: smoothing.x, y: smoothing.y};
    }

    function stopDrawing(){ drawing = false; lastPoint = null }

    function clearCanvas(){
      const ctx = drawCanvas.getContext('2d');
      ctx.clearRect(0,0,drawCanvas.width,drawCanvas.height);
    }

    clearBtn.addEventListener('click', ()=>{ clearCanvas(); setStatus('canvas cleared') });
    saveBtn.addEventListener('click', ()=>{
      // merge video frame (mirrored) and drawing into an image
      const out = document.createElement('canvas');
      out.width = drawCanvas.width; out.height = drawCanvas.height;
      const ctx = out.getContext('2d');
      // draw mirrored video
      ctx.translate(out.width,0); ctx.scale(-1,1);
      ctx.drawImage(video,0,0,out.width,out.height);
      ctx.setTransform(1,0,0,1,0,0);
      ctx.drawImage(drawCanvas,0,0);
      const url = out.toDataURL('image/png');
      const a = document.createElement('a'); a.href = url; a.download = 'gesture-paint.png'; a.click();
    });

    stopBtn.addEventListener('click', ()=>{
      if(camera) camera.stop();
      setStatus('stopped');
    });

    // load MediaPipe Hands libs and start camera
    startBtn.addEventListener('click', async ()=>{
      setStatus('loading models...');
      // dynamic imports of MediaPipe scripts
      if(!window.Hands){
        await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js');
        await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js');
        await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js');
        await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js');
      }

      hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
      hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.6
      });

      hands.onResults(onResults);

      // start webcam
      const stream = await navigator.mediaDevices.getUserMedia({video:{width:1280,height:720}, audio:false});
      video.srcObject = stream;
      await video.play();
      fitCanvases();

      camera = new Camera(video, {
        onFrame: async () => { await hands.send({image: video}); },
        width: video.videoWidth || 1280,
        height: video.videoHeight || 720
      });
      camera.start();
      setStatus('camera running');

      // keep canvas size in sync on resize
      window.addEventListener('resize', fitCanvases);
    });

    function onResults(results){
      // draw landmarks on overlay for feedback and handle drawing
      const ctx = overlay.getContext('2d');
      ctx.clearRect(0,0,overlay.width,overlay.height);
      if(!results.multiHandLandmarks || results.multiHandLandmarks.length===0){ stopDrawing(); return }

      // we will use the first detected hand for drawing
      const landmarks = results.multiHandLandmarks[0];
      const w = overlay.width; const h = overlay.height;

      // draw small feedback circles
      for(const lm of landmarks){
        ctx.beginPath(); ctx.arc(lm.x * w, lm.y * h, 4,0,Math.PI*2); ctx.fillStyle='rgba(255,255,255,0.04)'; ctx.fill();
      }

      // index tip = landmark 8, thumb tip = 4
      const indexTip = landmarks[8];
      const thumbTip = landmarks[4];

      // compute a scale — use distance between wrist(0) and middle finger MCP (9) as reference size
      const refA = landmarks[0]; const refB = landmarks[9];
      const refDist = Math.hypot((refA.x-refB.x)*w,(refA.y-refB.y)*h) || Math.min(w,h)/6;

      const d = distance(indexTip, thumbTip, w, h);
      const threshold = Math.max(8, refDist * 0.25); // tuned threshold

      // draw tips and midpoint for visualization
      const mid = midpoint(indexTip, thumbTip, w, h);
      ctx.beginPath(); ctx.arc(indexTip.x*w, indexTip.y*h, 6,0,Math.PI*2); ctx.fillStyle = 'rgba(125,211,252,0.85)'; ctx.fill();
      ctx.beginPath(); ctx.arc(thumbTip.x*w, thumbTip.y*h, 6,0,Math.PI*2); ctx.fillStyle = 'rgba(251,146,60,0.85)'; ctx.fill();
      ctx.beginPath(); ctx.arc(mid.x, mid.y, 5,0,Math.PI*2); ctx.fillStyle='rgba(99,102,241,0.9)'; ctx.fill();

      // decide drawing mode
      if(d < threshold){
        // contact -> draw
        drawing = true;
        setStatus('drawing');
        drawLineTo(mid);
      }else{
        if(drawing) setStatus('paused');
        stopDrawing();
      }
    }

    // small helper to dynamically load scripts
    function loadScript(src){
      return new Promise((resolve,reject)=>{
        const s = document.createElement('script'); s.src = src; s.onload = resolve; s.onerror = reject; document.head.appendChild(s);
      });
    }
  </script>
</body>
</html>
