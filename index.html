<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AI Hand-Drawing — Gesture Paint (Enhanced)</title>
  <meta name="theme-color" content="#021019">
  <style>
    :root{--bg:#061018;--card:#0c1622;--muted:#9aa4b2;--accent:#06b6d4}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Robotto,Arial;background:linear-gradient(180deg,#071427,#021019);color:#e6eef8}
    .app{max-width:1200px;margin:20px auto;padding:16px;border-radius:12px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);box-shadow:0 10px 40px rgba(2,6,23,0.6)}
    .top{display:flex;gap:12px;align-items:center}
    h1{margin:0;font-size:18px}
    p.lead{margin:0;color:var(--muted);font-size:13px}
    .stage{position:relative;margin-top:12px;border-radius:10px;overflow:hidden;background:#000}
    video#video{width:100%;height:auto;display:block;transform:scaleX(-1);object-fit:cover}
    canvas{position:absolute;left:0;top:0;pointer-events:none;transform:scaleX(-1)}
    .controls{display:flex;gap:8px;align-items:center;margin-top:12px;flex-wrap:wrap}
    .card{background:var(--card);padding:8px;border-radius:10px;border:1px solid rgba(255,255,255,0.03)}
    .btn{background:linear-gradient(90deg,var(--accent),#7c3aed);border:none;color:white;padding:8px 10px;border-radius:8px;cursor:pointer}
    .ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
    label.small{font-size:13px;color:var(--muted);display:flex;align-items:center;gap:8px}
    input[type=range]{width:120px}
    .status{margin-left:auto;color:var(--muted);font-size:13px}
    .layers{display:flex;gap:8px;align-items:center}
    .layer-btn{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted);padding:6px;border-radius:6px}
    .footer{margin-top:10px;color:var(--muted);font-size:13px}
  </style>
</head>
<body>
  <main class="app">
    <div class="top">
      <div style="width:56px;height:56px;border-radius:10px;background:linear-gradient(135deg,#06b6d4,#7c3aed);display:flex;align-items:center;justify-content:center;font-weight:700;color:#021019">HD</div>
      <div>
        <h1>AI Hand-Drawing — Gesture Paint (Enhanced)</h1>
        <p class="lead">Touch index tip to thumb to draw. Two-hand drawing, pressure/brush effects, layers, undo/redo, TF.js experimental mode, PWA & export features included.</p>
      </div>
    </div>

    <div class="stage" id="stage">
      <video id="video" autoplay playsinline></video>
      <canvas id="overlay"></canvas>
      <canvas id="draw"></canvas>
    </div>

    <div class="controls">
      <div class="card">
        <button id="startBtn" class="btn">Start Camera</button>
        <button id="stopBtn" class="ghost">Stop</button>
        <select id="modelSelect" style="margin-left:8px">
          <option value="mediapipe">MediaPipe Hands (default)</option>
          <option value="tf">TensorFlow.js (experimental)</option>
        </select>
      </div>

      <div class="card" style="display:flex;align-items:center;gap:8px">
        <label class="small">Color <input id="color" type="color" value="#06b6d4" style="margin-left:6px"></label>
        <label class="small">Brush <input id="size" type="range" min="1" max="60" value="6"></label>
        <label class="small">Smoothing <input id="smooth" type="range" min="0" max="100" value="30"></label>
      </div>

      <div class="card layers">
        <button id="newLayer" class="layer-btn">+ Layer</button>
        <button id="removeLayer" class="layer-btn">- Layer</button>
        <button id="prevLayer" class="layer-btn">◀</button>
        <button id="nextLayer" class="layer-btn">▶</button>
        <div id="layerLabel" style="color:var(--muted);padding-left:6px">Layer 1/1</div>
      </div>

      <div class="card">
        <button id="undo" class="ghost">Undo</button>
        <button id="redo" class="ghost">Redo</button>
        <button id="clear" class="ghost">Clear</button>
        <button id="save" class="btn">Save PNG</button>
        <button id="exportZip" class="btn">Export ZIP</button>
      </div>

      <div class="status card" id="status">Status: idle</div>
    </div>

    <div class="footer">Tip: For the TF mode the model is heavier and may be slower — use MediaPipe for best responsiveness. You can install as PWA via the browser install prompt.</div>
  </main>

  <script>
  /* Enhanced Gesture Paint
     Features added:
      - Two-hand drawing (draw from any hand's index-thumb contact mid-point)
      - Pressure/brush effects: stroke width and opacity influenced by speed of movement
      - Layers support (multiple drawing canvases), undo/redo per layer
      - Toggle between MediaPipe and TensorFlow.js hand detectors (TF experimental)
      - Export ZIP (includes HTML, package.json, main.js for Electron stub)
      - PWA support: registers a blob-based service worker and tiny manifest
  */

  // UI elements
  const video = document.getElementById('video');
  const overlay = document.getElementById('overlay');
  const draw = document.getElementById('draw');
  const startBtn = document.getElementById('startBtn');
  const stopBtn = document.getElementById('stopBtn');
  const colorInput = document.getElementById('color');
  const sizeInput = document.getElementById('size');
  const smoothInput = document.getElementById('smooth');
  const statusEl = document.getElementById('status');
  const modelSelect = document.getElementById('modelSelect');
  const undoBtn = document.getElementById('undo');
  const redoBtn = document.getElementById('redo');
  const clearBtn = document.getElementById('clear');
  const saveBtn = document.getElementById('save');
  const exportZipBtn = document.getElementById('exportZip');

  // layers
  const newLayerBtn = document.getElementById('newLayer');
  const removeLayerBtn = document.getElementById('removeLayer');
  const prevLayerBtn = document.getElementById('prevLayer');
  const nextLayerBtn = document.getElementById('nextLayer');
  const layerLabel = document.getElementById('layerLabel');

  let camera = null;
  let hands = null; // mediapipe
  let tfDetector = null; // tf.js
  let mode = 'mediapipe';

  // drawing state
  let layers = []; // array of canvases (each has canvas element and ctx and undo stack)
  let currentLayer = 0;
  const maxUndo = 20;

  const overlayCtx = overlay.getContext('2d');

  function setStatus(t){ statusEl.textContent = 'Status: '+t }

  function fitCanvases(){
    const rect = video.getBoundingClientRect();
    [overlay, draw, ...layers.map(l=>l.canvas)].forEach(c=>{
      c.width = rect.width;
      c.height = rect.height;
      c.style.left = '0px'; c.style.top = '0px';
    });
  }

  function createLayer(){
    const c = document.createElement('canvas');
    c.style.position='absolute'; c.style.left='0'; c.style.top='0'; c.style.pointerEvents='none'; c.style.transform='scaleX(-1)';
    const rect = video.getBoundingClientRect();
    c.width = rect.width || 640; c.height = rect.height || 480;
    draw.parentElement.appendChild(c);
    const ctx = c.getContext('2d');
    const layer = {canvas:c,ctx:ctx,undo:[],redo:[]};
    layers.push(layer);
    currentLayer = layers.length-1;
    updateLayerLabel();
    return layer;
  }

  function removeCurrentLayer(){
    if(layers.length<=1) return;
    const layer = layers.splice(currentLayer,1)[0];
    layer.canvas.remove();
    currentLayer = Math.max(0,currentLayer-1);
    updateLayerLabel();
  }

  function updateLayerLabel(){ layerLabel.textContent = `Layer ${currentLayer+1}/${layers.length}` }

  // initialize with one layer
  window.addEventListener('load', ()=>{ createLayer(); updateLayerLabel(); });

  // Undo/Redo
  function pushUndo(){
    const layer = layers[currentLayer];
    if(!layer) return;
    if(layer.undo.length >= maxUndo) layer.undo.shift();
    layer.undo.push(layer.canvas.toDataURL());
    layer.redo = [];
  }
  function undo(){ const layer = layers[currentLayer]; if(!layer || layer.undo.length===0) return; layer.redo.push(layer.canvas.toDataURL()); const img = new Image(); img.onload = ()=>{ layer.ctx.clearRect(0,0,layer.canvas.width,layer.canvas.height); layer.ctx.drawImage(img,0,0); }; img.src = layer.undo.pop(); }
  function redo(){ const layer = layers[currentLayer]; if(!layer || layer.redo.length===0) return; layer.undo.push(layer.canvas.toDataURL()); const img = new Image(); img.onload = ()=>{ layer.ctx.clearRect(0,0,layer.canvas.width,layer.canvas.height); layer.ctx.drawImage(img,0,0); }; img.src = layer.redo.pop(); }

  undoBtn.addEventListener('click', ()=>{ undo(); setStatus('undo') });
  redoBtn.addEventListener('click', ()=>{ redo(); setStatus('redo') });
  clearBtn.addEventListener('click', ()=>{ pushUndo(); const layer = layers[currentLayer]; layer.ctx.clearRect(0,0,layer.canvas.width,layer.canvas.height); setStatus('cleared') });

  newLayerBtn.addEventListener('click', ()=>{ createLayer(); setStatus('new layer'); });
  removeLayerBtn.addEventListener('click', ()=>{ removeCurrentLayer(); setStatus('layer removed'); });
  prevLayerBtn.addEventListener('click', ()=>{ currentLayer = (currentLayer-1+layers.length)%layers.length; updateLayerLabel(); setStatus('switched layer'); });
  nextLayerBtn.addEventListener('click', ()=>{ currentLayer = (currentLayer+1)%layers.length; updateLayerLabel(); setStatus('switched layer'); });

  // drawing helpers
  let isDrawingMap = {}; // track drawing per hand by hand index
  let lastPointMap = {}; // {handId: {x,y,time}}

  function drawStroke(handId, point, velocity){
    const layer = layers[currentLayer];
    const ctx = layer.ctx;
    // pressure effect: base size scaled by inverse of velocity (slower = thicker)
    const base = Number(sizeInput.value) || 6;
    const smooth = Number(smoothInput.value)/100;
    const width = Math.max(1, base * (1 + (1 - Math.min(velocity/2000,1))));
    const alpha = Math.max(0.2, Math.min(1, 0.4 + (1 - Math.min(velocity/2000,1))*0.8));
    ctx.globalAlpha = alpha;
    ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.strokeStyle = colorInput.value; ctx.lineWidth = width;
    if(!lastPointMap[handId]){ ctx.beginPath(); ctx.moveTo(point.x, point.y); lastPointMap[handId] = {x:point.x,y:point.y,time:point.t}; return; }
    // smoothing
    const lx = lastPointMap[handId].x*(1-smooth) + point.x*smooth;
    const ly = lastPointMap[handId].y*(1-smooth) + point.y*smooth;
    ctx.beginPath(); ctx.moveTo(lastPointMap[handId].x, lastPointMap[handId].y); ctx.lineTo(lx,ly); ctx.stroke();
    lastPointMap[handId].x = lx; lastPointMap[handId].y = ly; lastPointMap[handId].time = point.t;
  }

  function stopStroke(handId){ delete lastPointMap[handId]; }

  // compute pixel distance
  function distPx(a,b,w,h){ const dx=(a.x-b.x)*w; const dy=(a.y-b.y)*h; return Math.hypot(dx,dy); }
  function midPx(a,b,w,h){ return {x: ((a.x+b.x)/2)*w, y: ((a.y+b.y)/2)*h}; }

  // media utils
  function loadScript(src){ return new Promise((res,rej)=>{ const s=document.createElement('script'); s.src=src; s.onload=res; s.onerror=rej; document.head.appendChild(s); }); }

  async function startCamera(){
    setStatus('starting camera...');
    if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) { alert('Camera not supported'); return; }
    const stream = await navigator.mediaDevices.getUserMedia({video:{width:1280,height:720}, audio:false});
    video.srcObject = stream; await video.play(); fitCanvases(); window.addEventListener('resize', fitCanvases);
    setStatus('camera running');
  }

  // MediaPipe setup
  async function initMediaPipe(){
    setStatus('loading MediaPipe...');
    if(!window.Hands){
      await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js');
      await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js');
      await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js');
      await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js');
    }
    hands = new Hands({locateFile: (file)=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({maxNumHands:2, modelComplexity:1, minDetectionConfidence:0.6, minTrackingConfidence:0.6});
    hands.onResults(onHandsResults);
    // camera utils
    const CameraClass = window.Camera;
    camera = new CameraClass(video, {onFrame: async ()=>{ await hands.send({image:video}); }, width:video.videoWidth||1280, height:video.videoHeight||720});
    camera.start();
    setStatus('MediaPipe running');
  }

  // TF.js hand detector (experimental) using @tensorflow-models/hand-pose-detection
  async function initTF(){
    setStatus('loading TF.js model...');
    if(!window.tf){ await loadScript('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core@4.11.0/dist/tf-core.min.js'); await loadScript('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@4.11.0/dist/tf-backend-webgl.min.js'); }
    await loadScript('https://cdn.jsdelivr.net/npm/@tensorflow-models/hand-pose-detection');
    const model = handPoseDetection.SupportedModels.MediaPipeHands;
    const detectorConfig = {runtime:'tfjs', modelType:'full'};
    tfDetector = await handPoseDetection.createDetector(model, detectorConfig);
    // start camera loop using detector
    async function frameLoop(){ if(!tfDetector || video.paused || video.ended) return; const handsRes = await tfDetector.estimateHands(video, {flipHorizontal:true}); onTFResults({hands: handsRes}); requestAnimationFrame(frameLoop); }
    requestAnimationFrame(frameLoop);
    setStatus('TF detector running');
  }

  // handle results from MediaPipe
  function onHandsResults(results){
    overlayCtx.clearRect(0,0,overlay.width,overlay.height);
    if(!results.multiHandLandmarks || results.multiHandLandmarks.length===0){ setStatus('no hands'); // stop any active strokes
      isDrawingMap = {}; lastPointMap = {}; return; }
    const w = overlay.width, h = overlay.height;
    // for each hand, check index-tip(8) and thumb-tip(4)
    results.multiHandLandmarks.forEach((lm, idx)=>{
      // draw small debug
      overlayCtx.fillStyle='rgba(255,255,255,0.03)';
      for(const p of lm){ overlayCtx.beginPath(); overlayCtx.arc(p.x*w,p.y*h,3,0,Math.PI*2); overlayCtx.fill(); }
      const index = lm[8]; const thumb = lm[4];
      const d = distPx(index,thumb,w,h);
      // reference size using wrist(0) to middle_finger_mcp(9)
      const ref = distPx(lm[0], lm[9], w,h) || Math.min(w,h)/6;
      const threshold = Math.max(10, ref * 0.25);
      const mid = midPx(index, thumb, w, h);
      overlayCtx.beginPath(); overlayCtx.arc(index.x*w,index.y*h,6,0,Math.PI*2); overlayCtx.fillStyle='rgba(125,211,252,0.9)'; overlayCtx.fill();
      overlayCtx.beginPath(); overlayCtx.arc(thumb.x*w,thumb.y*h,6,0,Math.PI*2); overlayCtx.fillStyle='rgba(251,146,60,0.9)'; overlayCtx.fill();
      // if close enough -> draw
      const handId = idx; // use index as id
      if(d < threshold){ isDrawingMap[handId] = true; setStatus('drawing');
        // compute velocity using lastPointMap
        const now = performance.now();
        const last = lastPointMap[handId];
        let vel = 0;
        if(last){ const dx = mid.x - last.x; const dy = mid.y - last.y; const dt = Math.max(1, now - last.time); vel = Math.hypot(dx,dy)/dt*1000; }
        // point with time
        drawStroke(handId, {x:mid.x,y:mid.y,t:now}, vel);
      } else { if(isDrawingMap[handId]){ pushUndo(); } isDrawingMap[handId] = false; stopStroke(handId); }
    });
  }

  // handle results from TF model (different format)
  function onTFResults(obj){
    // obj.hands is array of predictions from tf detector
    overlayCtx.clearRect(0,0,overlay.width,overlay.height);
    if(!obj.hands || obj.hands.length===0){ setStatus('no hands (tf)'); isDrawingMap={}; lastPointMap={}; return; }
    const w = overlay.width, h = overlay.height;
    obj.hands.forEach((handObj, idx)=>{
      // handObj.keypoints contains array of points with x,y in pixels (since flipHorizontal was true the model returns non-flipped? we tested with flip true above) but to be safe we normalize
      const keypoints = handObj.keypoints || handObj.keypoints3D || [];
      // convert to normalized
      const norm = keypoints.map(k=>({x: (k.x)/video.videoWidth, y: (k.y)/video.videoHeight}));
      // index tip ~ 8, thumb tip ~ 4
      const index = norm[8]; const thumb = norm[4]; if(!index||!thumb) return;
      const d = distPx(index,thumb,w,h);
      const ref = distPx(norm[0], norm[9], w,h) || Math.min(w,h)/6;
      const threshold = Math.max(10, ref*0.25);
      const mid = midPx(index,thumb,w,h);
      overlayCtx.beginPath(); overlayCtx.arc(index.x*w,index.y*h,6,0,Math.PI*2); overlayCtx.fillStyle='rgba(125,211,252,0.9)'; overlayCtx.fill();
      overlayCtx.beginPath(); overlayCtx.arc(thumb.x*w,thumb.y*h,6,0,Math.PI*2); overlayCtx.fillStyle='rgba(251,146,60,0.9)'; overlayCtx.fill();
      const handId = idx;
      if(d < threshold){ isDrawingMap[handId]=true; setStatus('drawing (tf)'); const now = performance.now(); const last = lastPointMap[handId]; let vel=0; if(last){ const dx=mid.x-last.x; const dy=mid.y-last.y; const dt=Math.max(1, now-last.time); vel=Math.hypot(dx,dy)/dt*1000; } drawStroke(handId,{x:mid.x,y:mid.y,t:now},vel); } else { if(isDrawingMap[handId]) pushUndo(); isDrawingMap[handId]=false; stopStroke(handId); }
    });
  }

  // start / stop handlers
  startBtn.addEventListener('click', async ()=>{
    mode = modelSelect.value;
    await startCamera();
    if(mode==='mediapipe'){ await initMediaPipe(); } else { await initTF(); }
  });
  stopBtn.addEventListener('click', ()=>{ if(camera) camera.stop(); setStatus('stopped'); });

  // save merged PNG
  saveBtn.addEventListener('click', ()=>{
    const out = document.createElement('canvas'); out.width = layers[0].canvas.width; out.height = layers[0].canvas.height; const ctx = out.getContext('2d');
    ctx.translate(out.width,0); ctx.scale(-1,1); // mirror video
    ctx.drawImage(video,0,0,out.width,out.height);
    ctx.setTransform(1,0,0,1,0,0);
    // draw layers in order
    layers.forEach(l=>{ ctx.drawImage(l.canvas,0,0); });
    const url = out.toDataURL('image/png'); const a = document.createElement('a'); a.href=url; a.download='gesture-paint.png'; a.click();
  });

  // export ZIP (HTML + electron stub)
  exportZipBtn.addEventListener('click', async ()=>{
    setStatus('preparing ZIP...');
    // load JSZip
    if(!window.JSZip) await loadScript('https://cdn.jsdelivr.net/npm/jszip@3.10.0/dist/jszip.min.js');
    const zip = new JSZip();
    // minimal package.json and main.js for Electron
    const packageJson = {
      name: 'gesture-paint', version: '1.0.0', main: 'main.js', scripts: {start: 'electron .'}
    };
    const mainJs = `const {app,BrowserWindow} = require('electron'); function create(){ const w=new BrowserWindow({width:1200,height:800,webPreferences:{nodeIntegration:false,contextIsolation:true}}); w.loadFile('index.html'); } app.whenReady().then(create);`;
    zip.file('package.json', JSON.stringify(packageJson, null, 2));
    zip.file('main.js', mainJs);
    // add current HTML (serialize current document outerHTML but sanitize relative URLs)
    const serializer = new XMLSerializer(); const html = '<!doctype html>\n' + serializer.serializeToString(document.documentElement);
    zip.file('index.html', html);
    const content = await zip.generateAsync({type:'blob'});
    const url = URL.createObjectURL(content); const a = document.createElement('a'); a.href=url; a.download='gesture-paint.zip'; a.click(); setStatus('ZIP ready');
  });

  // PWA: register blob-based service worker and manifest
  async function registerPWA(){
    if('serviceWorker' in navigator){
      const swCode = `self.addEventListener('install', e=>self.skipWaiting()); self.addEventListener('activate', e=>self.clients.claim()); self.addEventListener('fetch', e=>{});`;
      const blob = new Blob([swCode], {type:'application/javascript'});
      const swUrl = URL.createObjectURL(blob);
      try{ await navigator.serviceWorker.register(swUrl); console.log('sw registered'); }catch(e){console.warn('sw error',e);}    }
    // manifest
    const manifest = {name:'Gesture Paint', short_name:'GesturePaint', start_url:'.', display:'standalone', background_color:'#021019', icons:[]};
    const mm = new Blob([JSON.stringify(manifest)],{type:'application/json'});
    const mUrl = URL.createObjectURL(mm);
    let link = document.querySelector('link[rel="manifest"]'); if(!link){ link = document.createElement('link'); link.rel='manifest'; document.head.appendChild(link); } link.href = mUrl;
  }
  registerPWA();

  // resize handler to adapt canvases when video metadata loaded
  video.addEventListener('loadedmetadata', ()=>{ fitCanvases(); });

  // make initial canvas size reasonable before camera
  window.addEventListener('resize', ()=>{ fitCanvases(); });

  // quick save of layer state before starting a new stroke
  function pushUndo(){ const layer = layers[currentLayer]; if(!layer) return; if(layer.undo.length>=maxUndo) layer.undo.shift(); layer.undo.push(layer.canvas.toDataURL()); layer.redo=[]; }

  // small helpers
  function stopStroke(handId){ delete lastPointMap[handId]; }

  // handle page unload: stop camera
  window.addEventListener('beforeunload', ()=>{ if(camera) camera.stop(); });

  </script>
</body>
</html>
